---
title: 从几道题理解隐式转换
date: 2022-04-20
tags:
 - 隐式转换
categories: 
 - js深入
---




## 前言
 
说到隐式转换，大家可能掌握的程度就和我之前差不多，我觉得我是知道的，又不是那么知道，如果面试的话遇到各种花里胡哨的隐式转换题立马就不会给你看。想要具体看一些细节，刚看完懂了，碰到题还是不会～ 就像下图一样


![1000.webp](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9258bcc52fa4086acf0102e3de2cc4b~tplv-k3u1fbpfcp-watermark.image?)


但像之前那样往往就是因为看的时候没有很理解，并且知识简单的记住了。下边大家就和我一起从几道题入手，会会这个马冬梅（不是😂


## 一些规则

既然我们想要对相关知识进行掌握并且能做出题，那我们可不是乱做的，总是会有一些规则的，在我们最开始遇到的隐式转换问题，往往都是以“==” 形式进行判断，==相关的基本就是如下

1. NaN 和任何 包括自己都不 ==
2. bigint和symbol。不会和其他类型的 ==
3. null和undefined 只会和 null和undefined ==
4. 布尔值类型和其他类型比较，会转换数字比较
5. 数字类型和字符串类型比较，会转换数字
6. 对象类型和原始类型比较， 会转换原始类型



对象隐式转换三大方法

- symbol.toPrimitive
- Object.prototype.valueOf
- Object.prototype.toString






看着不好记没关系，等我们坐着题回头看的时候就会顺眼很多了



## 一些题目



#### null == 0

看到题目不要慌，有些小伙伴可能第一时间想不到，就有一些容易按照感觉随意判断了，这是不可以的。回想一下之前的规则。

> null和undefined 只会和 null和undefined ==

所以不要想乱七八糟的意义啦～ 看到左边是null，右边不是null或者0，直接 **false**！



#### '0' == false

那这个呢？ 看上去不能直接判断了，感觉像是对的又没有那么确定？

我们想一下之前的规则，和字符串和布尔值相关的规则，我们先从转变更宽松的规则看起


> 布尔值类型和其他类型比较，会转换数字比较

所以false相关的 顺理成章可以看成 0

如果用 ‘0’ 和 0比较的话，这样一看就顺眼多了

再根据另外一条定义

> 数字类型和字符串类型比较，会转换数字 

所以这道题确实是相等的 **为true**


#### [] + [] 

到这里，终于扣题了

又是之前总是让人头晕的又出现频率很高的几道题，所以我们一定要记住上边的规则，逐一转换

我们还记得上边的规则是这样的

> 对象类型和原始类型比较， 会转换原始类型

有同学一看说：哎？不对，上边的规则是对象类型和原始类型比较，这道题不是对象和对象么，没错是这样的，但是他们发生的隐式转换往往都是同样原理的，比如不管是“==”还是“+” 。对象进行操作的时候都需要转换成原始值

而对象需要转换成什么样的原始值呢？这就也是转换时涉及对象的一个复杂性

所以我们需要看一下对象转换相关的规则

symbol.toPrimitive 相关的转换比较少，我们这里先略过
至于转换具体是用valueof还是toString呢？ 优先级是情况而定，如果其中一个没有返回回来原始值，就会调另外一个

那把目光放回这道题本身上，[]+[] 无疑还是根据对象类型和原始类型比较， 会转换原始类型这条规律
因为[].valueOf 返回  []. 不是基本值，所以调用 String.prototype.toString，返回的为''。 所以 []+[] 就可以转换为 ''+'' 最后结果就是 ''


####   [] + {}

根据了上一道题的完成，这道题看上去也简单多了，[] 先看成'', 那{}也同样是通过String.prototype.toString进行转换，成为我们所熟悉的 '[object Object]'。最后的结果就是'[object Object]'



## 结尾

其实这种题不会做，往往就是因为基本的一些原理还是生疏了，不妨把文章多看几遍。如果遇到类似的问题一定会更加胸有成竹啦。如果有帮到你，可以给点个赞哦，加油
